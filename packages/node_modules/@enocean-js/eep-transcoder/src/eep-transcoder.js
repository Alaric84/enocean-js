import * as EEP from './eep.js'
import { ByteArray } from '../../byte-array/src/byte-array.js'

function getEEP (eep) {
  var c = EEP[eep.replace(/-/g, '')]
  if (c.hasOwnProperty('ref')) {
    c = EEP[c.ref.replace(/-/g, '')]
  }
  return c
}

function getConditionType (item) {
  if (item.hasOwnProperty('condition')) {
    if (item.condition.hasOwnProperty('statusfield')) {
      return 'status'
    }
    if (item.condition.hasOwnProperty('datafield')) {
      return 'data'
    }
    if (item.condition.hasOwnProperty('direction')) {
      return 'direction'
    }
  }
  return 'none'
}

function createStatusByte (fields) {
  var status = ByteArray.from(0)
  return fields.reduce((a, x) => {
    a.setSingleBit(parseInt(x.bitoffs), parseInt(x.value))
    return a
  }, status)
}

function getEEPDescriptor (options) {
  var selector = { ...{ direction: 1, status: 0, payload: ByteArray.from([0, 0, 0, 0]), data: 1 }, ...options }
  var c = getEEP(selector.eep)
  return c.case.find(function (item) {
    switch (getConditionType(item)) {
      case 'status':
        var itemStatus = createStatusByte(item.condition.statusfield)
        if (itemStatus[0] === selector.status) {
          return true
        }
        break
      case 'data':
        const cond = selector.payload.getValue(parseInt(item.condition.datafield.bitoffs), parseInt(item.condition.datafield.bitsize))
        if (parseInt(item.condition.datafield.value) === (cond === 0 ? selector.data : cond)) {
          return true
        }
        break
      case 'direction':
        if (parseInt(item.condition.direction) === selector.direction) {
          return true
        }
        break
      case 'none':
      default:
        return true
    }
  })
}

export function decode (radio, eep, direction = 1) {
  return Object.freeze(
    decodeCase(radio.payload,
      getEEPDescriptor({
        eep: eep,
        direction: direction,
        status: radio.status,
        payload: radio.payload
      })
    )
  )
}

function decodeCase (tel, c) {
  if (!Array.isArray(c.datafield)) c.datafield = [c.datafield]
  var ret = c.datafield.reduce(makeFieldExtractor(tel), {})
  return ret
}

/**
*
*/
function makeFieldExtractor (payload) {
  return function (returnValue, datafield, index, array) {
    var rawValue = payload.getValue(parseInt(datafield.bitoffs), parseInt(datafield.bitsize))
    var unit = getUnit(datafield, array, payload)
    switch (getFieldType(datafield)) {
      case 'enum':
        returnValue[datafield.shortcut] = {
          ...{ name: datafield.data, unit: unit, rawValue: rawValue },
          ...extractEnumValue(rawValue, datafield.enum.item)
        }
        break
      case 'range':
        returnValue[datafield.shortcut] = { name: datafield.data, rawValue: rawValue, value: extractRangeValue(rawValue, datafield, array, payload), range: datafield.range, scale: datafield.scale, unit: unit }
        break
      case 'reserved':
        break
      case 'raw':
      default:
        returnValue[datafield.shortcut] = { name: datafield.data, value: rawValue, unit: unit }
    }
    return returnValue
  }
}

function getFieldType (datafield) {
  if (datafield.hasOwnProperty('enum') && datafield.enum.hasOwnProperty('item')) {
    return 'enum'
  }
  if (datafield.hasOwnProperty('range')) {
    return 'range'
  }
  if (datafield.hasOwnProperty('reserved')) {
    return 'reserved'
  }
  return 'raw'
}

function getDataFieldByShortcut (datafield, shortcut) {
  return datafield.find(item => item.shortcut === shortcut)
}

function extractEnumValue (value, list) {
  if (!Array.isArray(list)) list = [list]
  return list.find(item => {
    if (item.hasOwnProperty('min')) {
      if (parseInt(item.min) <= value && parseInt(item.max) >= value) {
        item.value = value
        return true
      }
    }
    if (item.hasOwnProperty('bitmask')) {
      var mask = parseInt(item.bitmask)
      if ((value & mask) === parseInt(item.value)) {
        return true
      }
    }
    if (item.hasOwnProperty('scale') && (parseInt(item.value) === value)) {
      return true
    }
    if (parseInt(item.value) === value) {
      return true
    }
  })
}

function extractRangeValue (rawValue, datafield, array, payload) {
  if (!datafield.hasOwnProperty('scale')) {
    datafield.scale = datafield.range
  }
  var scale = datafield.scale
  var range = datafield.range
  if (datafield.scale.hasOwnProperty('ref')) {
    scale = getRefField(datafield.scale.ref, array, payload).scale
  }
  if (datafield.range.hasOwnProperty('ref')) {
    range = getRefField(datafield.range.ref, array, payload).range
  }
  if (datafield.hasOwnProperty('LSB')) {
    var desc = getDataFieldByShortcut(array, datafield.LSB.ref)
    var ref = getRefField(datafield.LSB.ref, array, payload)
    var lsb = ref.rawValue.toString(2).padStart(desc.bitsize, '0')
    var msb = rawValue.toString(2).padStart(datafield.bitsize, '0')
    rawValue = parseInt(msb + lsb, 2)
  }
  return mapValue(rawValue, range, scale)
}

function mapValue (value, range, scale) {
  var rangeDistance = Number(range.max) - Number(range.min)
  var scaleDistance = Number(scale.max) - Number(scale.min)
  var dx = (scaleDistance / rangeDistance)
  return (value - Number(range.min)) * dx + Number(scale.min)
}

/**
* returns a value for a field by it's shortname
* @param {string} shortname - the shortname of the field
* @param {object} fieldDesc - the filed descriptor for the current eep
* @param {ByteArray} payload - the payload to extract the value from
*/
function getRefField (shortname, fieldDescs, payload) {
  return makeFieldExtractor(payload)({}, getDataFieldByShortcut(fieldDescs, shortname), 0, payload)[shortname]
}

function getUnit (datafield, array, payload) {
  var unit = ''
  if (datafield.hasOwnProperty('unit')) {
    unit = datafield.unit
    if (datafield.unit.hasOwnProperty('ref')) {
      unit = getRefField(datafield.unit.ref, array, payload).unit
    }
  }
  return unit
}

function setRangeValue (rawValue, datafield, eep, payload) {
  if (!datafield.hasOwnProperty('scale')) {
    datafield.scale = datafield.range
  }

  var scale = datafield.scale
  var range = datafield.range
  if (datafield.scale.hasOwnProperty('ref')) {
    scale = getRefField(datafield.scale.ref, eep, payload).scale
  }
  if (datafield.range.hasOwnProperty('ref')) {
    range = getRefField(datafield.range.ref, eep, payload).range
  }
  // if (datafield.hasOwnProperty('LSB')) {
  //   var desc = getDataFieldByShortcut(array, datafield.LSB.ref)
  //   var ref = getRefField(datafield.LSB.ref, array, payload)
  //   var lsb = ref.rawValue.toString(2).padStart(desc.bitsize, '0')
  //   var msb = rawValue.toString(2).padStart(datafield.bitsize, '0')
  //   rawValue = parseInt(msb + lsb, 2)
  // }
  return mapValue(rawValue, scale, range)
}

export function encodeData (data, options) {
  var selector = { ...{ eep: 'f6-01-01', direction: 1, status: 0, payload: ByteArray.from([0, 0, 0, 0]), data: 1 }, ...options }

  var payload = selector.payload
  for (var name in data) {
    var desc = getEEPDescriptor({
      eep: selector.eep,
      direction: selector.direction,
      status: selector.status,
      payload: payload,
      data: selector.data
    })
    const field = getDataFieldByShortcut(desc.datafield, name)
    const fieldType = getFieldType(field)
    if (fieldType === 'range') {
      var v = setRangeValue(data[name], field, desc.datafield, payload)
      payload.setValue(Math.round(v), parseInt(field.bitoffs), parseInt(field.bitsize))
    } else {
      payload.setValue(data[name], parseInt(field.bitoffs), parseInt(field.bitsize))
    }
  }
  return payload
}

export function getTeachInInfo (telegram) {
  const p = telegram
  if (p.RORG === 0xa5 || p.RORG === 0xd5) {
    var rorg, func, typ, manId
    if (p.RORG === 0xd5) {
      rorg = p.RORG
      func = 0x00
      typ = 0x01
      manId = 0x00
    } else {
      rorg = p.RORG
      func = p.payload.getValue(0, 6)
      typ = p.payload.getValue(6, 7)
      manId = p.payload.getValue(13, 10)
    }
    return {
      teachInType: p.RORG === 0xa5 ? '4BS' : '1BS',
      senderId: p.senderId,
      eep: {
        rorg,
        func,
        type: typ,
        toString () {
          return `${this.rorg.toString(16).padStart(2, '0')}-${this.func.toString(16).padStart(2, '0')}-${this.type.toString(16).padStart(2, '0')}`
        }
      },
      manufacturer: {
        id: manId,
        name: ''
      }
    }
  }
  if (p.RORG === 0xf6) {
    return {
      teachInType: 'RPS',
      senderId: p.senderId,
      eep: {
        rorg: 0xf6,
        func: 0x02,
        type: 0x01,
        toString () {
          return `f6-02-01`
        }
      }
    }
  }
  if (p.RORG === 0xd4) {
    return {
      teachInType: 'UTE',
      senderId: p.senderId
    }
  }
}
