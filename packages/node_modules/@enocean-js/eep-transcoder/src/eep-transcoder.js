import * as EEP from './eep.js'
import { ByteArray } from '../../byte-array/src/byte-array.js'

function getConditionType (item) {
  if (item.hasOwnProperty('condition')) {
    if (item.condition.hasOwnProperty('statusfield')) {
      return 'status'
    }
    if (item.condition.hasOwnProperty('datafield')) {
      return 'data'
    }
    if (item.condition.hasOwnProperty('direction')) {
      return 'direction'
    }
  }
  return 'none'
}

function createStatusByte (fields) {
  var status = ByteArray.from(0)
  return fields.reduce((a, x) => {
    a.setSingleBit(parseInt(x.bitoffs), parseInt(x.value))
    return a
  }, status)
}

export function decode (radio, eep, direction) {
  var c = EEP[eep.replace(/-/g, '')]
  var decoded = {}
  if (c.hasOwnProperty('ref')) {
    c = EEP[c.ref.replace(/-/g, '')]
  }
  c.case.some(function (item) {
    switch (getConditionType(item)) {
      case 'status':
        var status = createStatusByte(item.condition.statusfield)
        if (status[0] === radio.status) {
          decoded = decodeCase(radio.payload, item)
          return true
        }
        break
      case 'data':
        const cond = radio.data.getValue(parseInt(item.condition.datafield.bitoffs), parseInt(item.condition.datafield.bitsize))
        if (parseInt(item.condition.datafield.value) === cond) {
          decoded = decodeCase(radio.payload, item)
          return true
        }
        break
      case 'direction':
        if (parseInt(item.condition.direction) === direction) {
          decoded = decodeCase(radio.payload, item)
          return true
        }
        break
      case 'none':
      default:
        decoded = decodeCase(radio.payload, item)
    }
  })
  return Object.freeze(decoded)
}

function decodeCase (tel, c) {
  if (!Array.isArray(c.datafield)) c.datafield = [c.datafield]
  var ret = c.datafield.reduce(makeFieldExtractor(tel), {})
  return ret
}

/**
*
*/
function makeFieldExtractor (payload) {
  return function (returnValue, datafield, index, array) {
    var rawValue = payload.getValue(parseInt(datafield.bitoffs), parseInt(datafield.bitsize))
    var unit = getUnit(datafield, array, payload)
    switch (getFieldType(datafield)) {
      case 'enum':
        returnValue[datafield.shortcut] = {
          ...{ name: datafield.data, unit: unit, rawValue: rawValue },
          ...extractEnumValue(rawValue, datafield.enum.item)
        }
        break
      case 'range':
        returnValue[datafield.shortcut] = { name: datafield.data, rawValue: rawValue, value: extractRangeValue(rawValue, datafield, array, payload), range: datafield.range, scale: datafield.scale, unit: unit }
        break
      case 'reserved':
        break
      case 'raw':
      default:
        returnValue[datafield.shortcut] = { name: datafield.data, value: rawValue, unit: unit }
    }
    return returnValue
  }
}

function getFieldType (datafield) {
  if (datafield.hasOwnProperty('enum') && datafield.enum.hasOwnProperty('item')) {
    return 'enum'
  }
  if (datafield.hasOwnProperty('range')) {
    return 'range'
  }
  if (datafield.hasOwnProperty('reserved')) {
    return 'reserved'
  }
  return 'raw'
}

function getDataFieldByShortcut (datafield, shortcut) {
  return datafield.find(item => item.shortcut === shortcut)
}

function extractEnumValue (value, list) {
  if (!Array.isArray(list)) list = [list]
  return list.find(item => {
    if (item.hasOwnProperty('min')) {
      if (parseInt(item.min) <= value && parseInt(item.max) >= value) {
        return true
      }
    }
    if (item.hasOwnProperty('bitmask')) {
      var mask = parseInt(item.bitmask)
      if ((value & mask) === parseInt(item.value)) {
        return true
      }
    }
    if (item.hasOwnProperty('scale') && (parseInt(item.value) === value)) {
      return true
    }
    if (parseInt(item.value) === value) {
      return true
    }
  })
}

function extractRangeValue (rawValue, datafield, array, payload) {
  if (!datafield.hasOwnProperty('scale')) {
    datafield.scale = datafield.range
  }
  var scale = datafield.scale
  var range = datafield.range
  if (datafield.scale.hasOwnProperty('ref')) {
    scale = getRefField(datafield.scale.ref, array, payload).scale
  }
  if (datafield.range.hasOwnProperty('ref')) {
    range = getRefField(datafield.range.ref, array, payload).range
  }
  if (datafield.hasOwnProperty('LSB')) {
    var desc = getDataFieldByShortcut(array, datafield.LSB.ref)
    var ref = getRefField(datafield.LSB.ref, array, payload)
    var lsb = ref.rawValue.toString(2).padStart(desc.bitsize, '0')
    var msb = rawValue.toString(2).padStart(datafield.bitsize, '0')
    rawValue = parseInt(msb + lsb, 2)
  }
  return mapValue(rawValue, range, scale)
}

function mapValue (value, range, scale) {
  var rangeDistance = Number(range.max) - Number(range.min)
  var scaleDistance = Number(scale.max) - Number(scale.min)
  var dx = (scaleDistance / rangeDistance)
  return (value - Number(range.min)) * dx + Number(scale.min)
}

/**
* returns a value for a field by it's shortname
* @param {string} shortname - the shortname of the field
* @param {object} fieldDesc - the filed descriptor for the current eep
* @param {ByteArray} payload - the payload to extract the value from
*/
function getRefField (shortname, fieldDescs, payload) {
  return makeFieldExtractor(payload)({}, getDataFieldByShortcut(fieldDescs, shortname), 0, payload)[shortname]
}

function getUnit (datafield, array, payload) {
  var unit = ''
  if (datafield.hasOwnProperty('unit')) {
    unit = datafield.unit
    if (datafield.unit.hasOwnProperty('ref')) {
      unit = getRefField(datafield.unit.ref, array, payload).unit
    }
  }
  return unit
}

export function getTeachInInfo (telegram) {
  const p = telegram
  if (p.RORG === 0xa5 || p.RORG === 0xd5) {
    var rorg, func, typ, manId
    if (p.RORG === 0xd5) {
      rorg = p.RORG
      func = 0x00
      typ = 0x01
      manId = 0x00
    } else {
      rorg = p.RORG
      func = p.payload.getValue(0, 6)
      typ = p.payload.getValue(6, 7)
      manId = p.payload.getValue(13, 10)
    }
    return {
      teachInType: p.RORG === 0xa5 ? '4BS' : '1BS',
      senderId: p.senderId,
      eep: {
        rorg,
        func,
        type: typ,
        toString () {
          return `${this.rorg.toString(16).padStart(2, '0')}-${this.func.toString(16).padStart(2, '0')}-${this.type.toString(16).padStart(2, '0')}`
        }
      },
      manufacturer: {
        id: manId,
        name: ''
      }
    }
  }
  if (p.RORG === 0xf6) {
    return {
      teachInType: 'RPS',
      senderId: p.senderId,
      eep: {
        rorg: 0xf6,
        func: 0x02,
        type: 0x01,
        toString () {
          return `f6-02-01`
        }
      }
    }
  }
  if (p.RORG === 0xd4) {
    return {
      teachInType: 'UTE',
      senderId: p.senderId
    }
  }
}
