import { ESP3Packet } from '../ESP3Packet.js'
import { decode, getTeachInInfo } from '../../../eep-transcoder/src/eep-transcoder.js'
import { ByteArray } from '../../../byte-array/src/byte-array.js'

export const RadioERP1 = Object.create({})
RadioERP1.from = function (esp3Packet, eepDesc = {}) {
  var packet
  if (esp3Packet.hasOwnProperty('payload')) {
    var rorg
    var pl = ByteArray.from(esp3Packet.payload)
    switch (pl.length) {
      case 1:
        rorg = 0xf6
        break
      case 4:
        rorg = 0xf6
        break
      default:
        rorg = 0xd2
    }
    packet = ESP3Packet.from({
      data: [esp3Packet.rorg || rorg, pl, esp3Packet.id || '00000000', esp3Packet.status || 0],
      optionalData: [3, 'ffffffff', 'ff', 0], // always the same for sending ERP1
      packetType: 1 // always the same for sending ERP1
    })
  } else if (typeof esp3Packet === 'string') {
    packet = ESP3Packet.from(esp3Packet)
  } else {
    packet = esp3Packet
  }
  var res = {
    get packetType () {
      return 1
    },
    get RORG () {
      return packet.data[0]
    },
    get payload () {
      return packet.data.slice(1, packet.data.length - 5)
    },
    set payload (data) {
      var dataValue = ByteArray.from(data)
      dataValue.length = packet.dataLength - 6
      var newData = ByteArray.from(packet.data)
      newData.set(dataValue, 1)
      packet.data = newData
      packet.fixPacket()
    },
    get senderId () {
      return packet.data.slice(packet.data.length - 5, packet.data.length - 1).toString(16)
    },
    set senderId (id) {
      var idValue = ByteArray.from(id)
      idValue.length = 4
      var newData = ByteArray.from(packet.data)
      newData.set(idValue, packet.data.length - 5)
      packet.data = newData
      packet.fixPacket()
    },
    set status (val) {
      var dat = packet.data
      dat[packet.data.length - 1] = val
      packet.data = dat
      packet.fixPacket()
    },
    get status () {
      return packet.data[packet.data.length - 1]
    },
    get T21 () {
      return ByteArray.from(packet.status).getSingleBit(2)
    },
    set T21 (val) {
      this.status = ByteArray.from(this.status).setSingleBit(2, val)[0]
      packet.fixPacket()
    },
    get NU () {
      return ByteArray.from(this.status).getSingleBit(3)
    },
    set NU (val) {
      this.status = ByteArray.from(this.status).setSingleBit(3, val)[0]
      packet.fixPacket()
    },
    get subTelNum () {
      return packet.optionalData[0]
    },
    get destinationId () {
      return packet.optionalData.slice(1, 5).toString(16)
    },
    get RSSI () {
      return packet.optionalData[5]
    },
    get securityLevel () {
      return packet.optionalData[6]
    },
    get teachIn () {
      var mask = 1 << 3
      return (res.payload[res.payload.length - 1] & mask) === 0
    },
    decode (eep) {
      return decode(packet, eep)
    },
    get esp3Packet () {
      return packet
    },
    get teachInInfo () {
      return getTeachInInfo(this)
    }
  }
  return Object.freeze(res)
}

RadioERP1.connect = function (sender) {
  // var packet = ESP3Packet.from('550007070100f600aaaaaaaa0003ffffffffff0000')
  // var radioTelegram // = RadioERP1.from(packet) // default
  var members = {
    send (rorg, payload, id, status = 0) {
      var radioTelegram = ESP3Packet.from({
        data: [rorg, payload, id, status],
        optionalData: [3, 'ffffffff', 'ff', 0], // always the same for sending ERP1
        packetType: 1 // always the same for sending ERP1
      })
      return sender.send(radioTelegram.toString())
    }
  }
  return Object.freeze(members)
}
export default RadioERP1
