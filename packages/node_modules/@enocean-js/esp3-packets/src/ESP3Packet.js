import { toCRC8 } from '@enocean-js/crc8'
import ByteArray from '@enocean-js/byte-array'

const RESET = '\x1b[0m'
// const BRIGHT = '\x1b[1m'
const DIM = '\x1b[2m'
function toHex (val, len = 2) {
  return val.toString(16).padStart(len, '0')
}
function col (num) {
  return `\x1b[38;5;${num}m`
}
function colored (value, color) {
  return `${col(color)}${value}${RESET}`
}
function dim (value) {
  return `${DIM}${value}${RESET}`
}
const packetTypeColors = {
  0x01: 99,
  0x02: 203,
  0x05: 208
}

export const ESP3Packet = function (input) {
  const packetBytes = ByteArray.from(input)
  function setDataLength (value) {
    var byte0 = value % 256
    var byte1 = (value - byte0) / 256
    packetBytes.set([byte1, byte0], 1)
  }
  return {
    push (...value) {
      packetBytes.push(...value)
    },
    shift () {
      packetBytes.shift()
    },
    slice (...args) {
      packetBytes.slice(...args)
    },
    findIndex (func) {
      return packetBytes.findIndex(func)
    },
    getItem (index) {
      return packetBytes[index]
    },
    setItem (index, value) {
      packetBytes[index] = value
    },
    clear () {
      packetBytes.lenght = 0
    },
    get length () {
      return packetBytes.length
    },
    get dataLength () {
      return packetBytes[1] * 256 + packetBytes[2]
    },
    get optionalLength () {
      return packetBytes[3]
    },
    get packetType () {
      return packetBytes[4]
    },
    set packetType (value) {
      packetBytes[4] = value
    },
    get header () {
      return packetBytes.slice(1, 5)
    },
    get data () {
      return packetBytes.slice(6, 6 + this.dataLength)
    },
    set data (value) {
      value = ByteArray.from(value)
      var opt = this.optionalData
      packetBytes.splice(6, this.dataLength, ...value)
      packetBytes.splice(6 + value.length, this.optionalLength, ...opt)
      packetBytes.length = 7 + value.length + this.optionalLength
      setDataLength(value.length)
    },
    get optionalData () {
      return packetBytes.slice(6 + this.dataLength, 6 + this.dataLength + this.optionalLength)
    },
    set optionalData (value) {
      value = ByteArray.from(value)
      packetBytes.splice(6 + this.dataLength, value.length, ...value)
      packetBytes.length = 7 + this.dataLength + value.length
      packetBytes[3] = value.length
    },
    get body () {
      return packetBytes.slice(6, 6 + this.dataLength + this.optionalLength)
    },
    get crc8Data () {
      return packetBytes[6 + this.dataLength + this.optionalLength]
    },
    get crc8Header () {
      return packetBytes[5]
    },
    isHeaderOK () {
      return this.header.reduce(toCRC8, 0) === this.crc8Header
    },
    isBodyOK () {
      return this.body.reduce(toCRC8, 0) === this.crc8Data
    },
    isPacketOK () {
      return this.isHeaderOK() && this.isBodyOK()
    },
    fixPacket () {
      packetBytes[5] = this.header.reduce(toCRC8, 0)
      packetBytes[6 + this.dataLength + this.optionalLength] = this.body.reduce(toCRC8, 0)
    },
    toString (encoding = 'pretty') {
      if (encoding === 'pretty') {
        if (typeof window === 'undefined') {
          return `${dim(55)}.${colored(toHex(this.dataLength, 4), 39)}.${colored(toHex(this.optionalLength), 83)}.${colored(toHex(this.packetType), packetTypeColors[this.packetType])}.${dim(toHex(this.crc8Header))}.${colored(toHex(this.data), 39)}.${colored(this.optionalLength === 0 ? '' : toHex(this.optionalData), 83)}.${dim(toHex(this.crc8Data))}`
        } else {

        }
      }
      return packetBytes.toString(encoding)
    },
    toJSON () {
      return {
        syncByte: 0x55,
        header: {
          dataLength: this.dataLength,
          optionalLength: this.optionalLength,
          packetType: this.packetType
        },
        crc8Header: packetBytes[5],
        data: this.data,
        optionalData: this.optionalData,
        crc8Data: packetBytes[6 + this.dataLength + this.optionalLength]
      }
    }
  }
}
ESP3Packet.from = function (input) {
  let packet
  if (input && input.data) {
    packet = ESP3Packet('5500010001000000')
    packet.data = input.data
    packet.optionalData = input.optionalData || []
    packet.packetType = input.packetType || 1
    packet.fixPacket()
  } else {
    packet = ESP3Packet(input)
  }
  return packet
}
export default ESP3Packet
