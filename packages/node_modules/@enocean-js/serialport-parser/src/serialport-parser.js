// Copyright 2018 Holger Will <h.will@klimapartner.de>
import { makeESP3Packet } from '@enocean-js/esp3-packets'

const Transform = require('stream').Transform

const WAIT_FOR_SYNC_BYTE = 0
const FILL_HEADER = 1
const CHECK_CRC8_HEADER = 2
const FILL_DATA_OPTIONALDATA = 3
const CHECK_CRC8_DATAS = 4

const WRONG_HEADER_CHECKSUM_ERROR = 1
const WRONG_BODY_CHECKSUM_ERROR = 2
const ILLEGAL_PACKET_LENGTH_ERROR = 3
const BUFFER_OVERFLOW_ERROR = 4

class ESP3Parser extends Transform {
  constructor (options = { maxBufferSize: 65535 }) {
    super({ ...options, ...{ readableObjectMode: true } })
    this.currentESP3Packet = makeESP3Packet()
    this.state = WAIT_FOR_SYNC_BYTE
    this.maxBufferSize = options.maxBufferSize
  }
  _transform (chunk, encoding, cb) {
    for (var offset = 0; offset < chunk.length; offset++) {
      let byte = chunk[offset]
      switch (this.state) {
        case WAIT_FOR_SYNC_BYTE:
          if (byte === 0x55) {
            this.currentESP3Packet = makeESP3Packet(byte)
            this.state = FILL_HEADER
          }
          break
        case FILL_HEADER:
          this.currentESP3Packet.push(byte)
          if (this.currentESP3Packet.length < 5) {
            break
          }
          this.state = CHECK_CRC8_HEADER
          break
        case CHECK_CRC8_HEADER:
          this.currentESP3Packet.push(byte)
          if (!this.currentESP3Packet.isHeaderOK()) {
            var syncCodeIndex = this.currentESP3Packet.findIndex((item, index) => { return (item === 0x55) && (index > 0) })
            if (syncCodeIndex > 0) {
              this.state = FILL_HEADER
              while (syncCodeIndex > 0) {
                this.currentESP3Packet.shift()
                syncCodeIndex--
              }
              break
            }
            this.emit('error', {
              code: WRONG_HEADER_CHECKSUM_ERROR,
              name: 'WRONG_HEADER_CHECKSUM_ERROR',
              desc: 'header checksum test failed'
            })
            this.state = WAIT_FOR_SYNC_BYTE
            break
          }
          if (this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength <= 0) {
            this.emit('error', {
              code: ILLEGAL_PACKET_LENGTH_ERROR,
              name: 'ILLEGAL_PACKET_LENGTH_ERROR',
              desc: 'there must be at least 1 byte of data or optional data, it can not be 0'
            })
            this.state = WAIT_FOR_SYNC_BYTE
            break
          }
          this.state = FILL_DATA_OPTIONALDATA
          break
        case FILL_DATA_OPTIONALDATA:
          this.currentESP3Packet.push(byte)
          if (this.currentESP3Packet.length > this.maxBufferSize) {
            this.state = WAIT_FOR_SYNC_BYTE
            this.emit('error', {
              code: BUFFER_OVERFLOW_ERROR,
              name: 'BUFFER_OVERFLOW_ERROR',
              desc: `Max Buffer Size is ${this.maxBufferSize} Bytes`
            })
            break
          }
          if (this.currentESP3Packet.length < this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength + 6) {
            break
          }
          this.state = CHECK_CRC8_DATAS
          break
        case CHECK_CRC8_DATAS:
          this.currentESP3Packet.push(byte)
          this.state = WAIT_FOR_SYNC_BYTE
          if (!this.currentESP3Packet.isBodyOK()) {
            this.emit('error', {
              code: 2,
              name: 'WRONG_BODY_CHECKSUM',
              desc: 'data checksum test failed'
            })
            break
          }
          this.push(this.currentESP3Packet)
          break
      }
    }
    cb()
  }
  _flush (cb) {
  }
}

class ESP3AltParser extends Transform {
  constructor (options = { maxBufferSize: 65535 }) {
    super({ ...options, ...{ readableObjectMode: true } })
    this.currentESP3Packet = makeESP3Packet()
    this.callbackForNextByte = this.waitForSyncByte
    this.maxBufferSize = options.maxBufferSize
  }
  _transform (chunk, encoding, cb) {
    for (var offset = 0; offset < chunk.length; offset++) {
      this.callbackForNextByte(chunk[offset])
    }
    cb()
  }
  waitForSyncByte (byte) {
    if (byte === 0x55) {
      this.currentESP3Packet = makeESP3Packet(byte)
      this.callbackForNextByte = this.fillHeader
    }
  }
  fillHeader (byte) {
    this.currentESP3Packet.push(byte)
    if (this.currentESP3Packet.length < 5) {
      return
    }
    this.callbackForNextByte = this.checkCRC8Header
  }
  checkCRC8Header (byte) {
    this.currentESP3Packet.push(byte)
    if (!this.currentESP3Packet.isHeaderOK()) {
      var syncCodeIndex = this.currentESP3Packet.findIndex((item, index) => { return (item === 0x55) && (index > 0) })
      if (syncCodeIndex > 0) {
        this.callbackForNextByte = this.fillHeader
        while (syncCodeIndex > 0) {
          this.currentESP3Packet.shift()
          syncCodeIndex--
        }
        return
      }
      this.emit('error', {
        code: WRONG_HEADER_CHECKSUM_ERROR,
        name: 'WRONG_HEADER_CHECKSUM_ERROR',
        desc: 'header checksum test failed'
      })
      this.callbackForNextByte = this.waitForSyncByte
      return
    }
    if (this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength <= 0) {
      this.emit('error', {
        code: ILLEGAL_PACKET_LENGTH_ERROR,
        name: 'ILLEGAL_PACKET_LENGTH_ERROR',
        desc: 'there must be at least 1 byte of data or optional data, it can not be 0'
      })
      this.callbackForNextByte = this.waitForSyncByte
      return
    }
    this.callbackForNextByte = this.fillDataAndOptionalData
  }
  fillDataAndOptionalData (byte) {
    this.currentESP3Packet.push(byte)
    if (this.currentESP3Packet.length > this.maxBufferSize) {
      this.callbackForNextByte = this.waitForSyncByte
      this.emit('error', {
        code: BUFFER_OVERFLOW_ERROR,
        name: 'BUFFER_OVERFLOW_ERROR',
        desc: `Max Buffer Size is ${this.maxBufferSize} Bytes`
      })
      return
    }
    if (this.currentESP3Packet.length < this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength + 6) {
      return
    }
    this.callbackForNextByte = this.checkCRC8Datas
  }
  checkCRC8Datas (byte) {
    this.currentESP3Packet.push(byte)
    this.callbackForNextByte = this.waitForSyncByte
    if (!this.currentESP3Packet.isBodyOK()) {
      this.emit('error', {
        code: WRONG_BODY_CHECKSUM_ERROR,
        name: 'WRONG_BODY_CHECKSUM_ERROR',
        desc: 'data checksum test failed'
      })
      return
    }
    this.push(this.currentESP3Packet)
  }
  _flush (cb) {
  }
}

export default ESP3Parser
export { ESP3Parser, ESP3AltParser }
