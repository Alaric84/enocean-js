// Copyright 2015 Rafael KÃ¤hm <rafael@kaehms.de>
// Copyright 2018 Holger Will <h.will@klimapartner.de>
import getCRC8 from '@enocean-js/crc8'
const Transform = require('stream').Transform

class ESP3Parser extends Transform {
  constructor (options = {}) {
    super({ ...options, ...{ readableObjectMode: true } })
    this.currentESP3Packet = {}
    this.rawString = ''
    this.tmp = null
    this.callbackForNextByte = this.waitForSyncByte
  }
  _transform (chunk, encoding, cb) {
    for (var offset = 0; offset < chunk.length; offset++) {
      this.rawString += chunk[offset].toString(16).padStart(2, '0')
      this.callbackForNextByte(chunk[offset], cb)
    }
    cb()
  }
  waitForSyncByte (byte, cb) {
    if (byte !== 0x55) {
      return
    }
    this.tmp = {
      'header': Buffer.alloc(4),
      'headerOffset': 0,
      'dataOffset': 0,
      'optionalDataOffset': 0
    }
    this.rawString = '55'
    this.callbackForNextByte = this.fillHeader
  }

  fillHeader (byte, cb) {
    if (this.tmp.headerOffset < 3) {
      this.tmp.header.fill(byte, this.tmp.headerOffset)
      this.tmp.headerOffset++
      return
    }
    this.tmp.header.fill(byte, this.tmp.headerOffset)
    this.currentESP3Packet.dataLength = Buffer.from([this.tmp.header[0], this.tmp.header[1]]).readUInt16BE(0)
    this.currentESP3Packet.optionalLength = this.tmp.header[2]
    this.currentESP3Packet.packetType = this.tmp.header[3]
    this.callbackForNextByte = this.fetchCRC8ForHeaderAndCheck
  }
  fetchCRC8ForHeaderAndCheck (byte, cb) {
    if (getCRC8(this.tmp.header) !== byte) {
      this.callbackForNextByte = this.waitForSyncByte
      this.emit('error', {
        code: 1,
        name: 'WRONG_HEADER_CHECKSUM',
        desc: 'header checksum test failed'
      })
      return
    }
    this.currentESP3Packet.crc8Header = byte
    this.currentESP3Packet.data = Buffer.alloc(this.currentESP3Packet.dataLength)
    // @todo: is 0 bytes buffer really needed? -> maybe "if (currentESP3Packet.header.optionalLength > 0)"?
    this.currentESP3Packet.optionalData = Buffer.alloc(this.currentESP3Packet.optionalLength)
    this.callbackForNextByte = this.fillData
  }
  fillData (byte, cb) {
    if (this.tmp.dataOffset < this.currentESP3Packet.dataLength - 1) {
      this.currentESP3Packet.data.fill(byte, this.tmp.dataOffset)
      this.tmp.dataOffset++
      return
    }
    this.currentESP3Packet.data.fill(byte, this.tmp.dataOffset)

    if (this.currentESP3Packet.optionalLength > 0) {
      this.callbackForNextByte = this.fillOptionalData
      return
    }
    this.callbackForNextByte = this.fetchCRC8ForDataAndCheck
  }
  fillOptionalData (byte, cb) {
    if (this.tmp.optionalDataOffset < this.currentESP3Packet.optionalLength - 1) {
      this.currentESP3Packet.optionalData.fill(byte, this.tmp.optionalDataOffset)
      this.tmp.optionalDataOffset++
      return
    }
    this.currentESP3Packet.optionalData.fill(byte, this.tmp.optionalDataOffset)
    this.callbackForNextByte = this.fetchCRC8ForDataAndCheck
  }
  fetchCRC8ForDataAndCheck (byte, cb) {
    this.callbackForNextByte = this.waitForSyncByte
    var datas = Buffer.concat(
      [this.currentESP3Packet.data, this.currentESP3Packet.optionalData],
      (this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength)
    )
    if (getCRC8(datas) !== byte) {
      this.emit('error', {
        code: 2,
        name: 'WRONG_BODY_CHECKSUM',
        desc: 'data checksum test failed'
      })
      return
    }
    this.currentESP3Packet.crc8Data = byte
    this._flush(cb)
  }
  _flush (cb) {
    this.push(this.rawString)
    this.rawString = ''
    this.currentESP3Packet = {}
  }
}
module.exports = ESP3Parser
